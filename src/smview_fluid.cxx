// generated by Fast Light User Interface Designer (fluid) version 1.0304

#include "smview_fluid.h"

void MainUI::cb_mainWindow_i(Fl_Double_Window*, void*) {
  OnClose();
}
void MainUI::cb_mainWindow(Fl_Double_Window* o, void* v) {
  ((MainUI*)(o->user_data()))->cb_mainWindow_i(o,v);
}

void MainUI::cb_SongList_i(Fl_Tabs*, char*) {
  // if Recent is selected, hide the Index menu
	if (SongList->value() == this->TabRecent) {
		IndexTab->hide();
		IndexTab->user_data((void*)('X'));
	}
	else {
		IndexTab->user_data((void*)('I'));
		IndexTab->show();
	};
}
void MainUI::cb_SongList(Fl_Tabs* o, char* v) {
  ((MainUI*)(o->parent()->user_data()))->cb_SongList_i(o,v);
}

void MainUI::cb_ArtistBrowser_i(Fl_Browser*, void*) {
  // reject the click if there is no user data (i.e. you clicked on the artist)
	if (ArtistBrowser->data(ArtistBrowser->value()) == NULL) {
		this->double_clicked = 0;
		ArtistBrowser->value(last_artist);
	}
	else this->last_artist = ArtistBrowser->value();
	// detect double click
	if (this->double_clicked > 0) {
		ShowPDF(ArtistBrowser->data(last_artist));  // show pdf here
	} else {
		// start double-click timer
		this->double_clicked++;
		Fl::add_timeout(0.25, dbl_click_chk, (void *)&double_clicked);
	};
}
void MainUI::cb_ArtistBrowser(Fl_Browser* o, void* v) {
  ((MainUI*)(o->parent()->parent()->parent()->user_data()))->cb_ArtistBrowser_i(o,v);
}

void MainUI::cb_TitleBrowser_i(Fl_Browser*, void*) {
  // reject the click if there is no user data (i.e. you clicked on the artist)
	if (TitleBrowser->data(TitleBrowser->value()) == NULL) {
		this->double_clicked = 0;
		TitleBrowser->value(last_title);
	}
	else this->last_title = TitleBrowser->value();
	// detect double click
	if (this->double_clicked > 0) {
		ShowPDF(TitleBrowser->data(last_title));  // show pdf here
	} else {
		// start double-click timer
		this->double_clicked++;
		Fl::add_timeout(0.25, dbl_click_chk, (void *)&double_clicked);
	};
}
void MainUI::cb_TitleBrowser(Fl_Browser* o, void* v) {
  ((MainUI*)(o->parent()->parent()->parent()->user_data()))->cb_TitleBrowser_i(o,v);
}

void MainUI::cb_RecentBrowser_i(Fl_Browser*, void*) {
  // reject the click if there is no user data (i.e. you clicked on the artist)
	if (RecentBrowser->data(RecentBrowser->value()) == NULL) {
		this->double_clicked = 0;
		RecentBrowser->value(last_date);
	}
	else this->last_date = RecentBrowser->value();
	// detect double click
	if (this->double_clicked > 0) {
		ShowPDF(RecentBrowser->data(last_date));  // show pdf here
	} else {
		// start double-click timer
		this->double_clicked++;
		Fl::add_timeout(0.25, dbl_click_chk, (void *)&double_clicked);
	};
}
void MainUI::cb_RecentBrowser(Fl_Browser* o, void* v) {
  ((MainUI*)(o->parent()->parent()->parent()->user_data()))->cb_RecentBrowser_i(o,v);
}

void MainUI::cb_HideButton_i(Fl_Button*, char*) {
  HideBrowsers();
}
void MainUI::cb_HideButton(Fl_Button* o, char* v) {
  ((MainUI*)(o->parent()->user_data()))->cb_HideButton_i(o,v);
}

#include <FL/Fl_Pixmap.H>
static const char *idata_HIDE[] = {
"29 29 3 1",
" \tc None",
".\tc #FF0000",
"+\tc #000000",
".............................",
"..................+..........",
".................++..........",
"................+++..........",
"...............++++..........",
"..............+++++..........",
".............++++++..........",
"............+++++++..........",
"...........++++++++..........",
"..........+++++++++..........",
".........++++++++++..........",
"........++++++++++...........",
".......++++++++++............",
"......++++++++++.............",
".....++++++++++..............",
"......++++++++++.............",
".......++++++++++............",
"........++++++++++...........",
".........++++++++++..........",
"..........+++++++++..........",
"...........++++++++..........",
"............+++++++..........",
".............++++++..........",
"..............+++++..........",
"...............++++..........",
"................+++..........",
".................++..........",
"..................+..........",
"............................."
};
static Fl_Image *image_HIDE() {
  static Fl_Image *image = new Fl_Pixmap(idata_HIDE);
  return image;
}

void MainUI::cb_IndexTab_i(Fl_Browser*, char*) {
  char c;
  c = IndexTab->value();
  if (c == 1) {
	  StartsWith('#'); 
	  return;
  }
  StartsWith('A' + c - 2);
  return;
}
void MainUI::cb_IndexTab(Fl_Browser* o, char* v) {
  ((MainUI*)(o->parent()->user_data()))->cb_IndexTab_i(o,v);
}

MainUI::MainUI() {
  { mainWindow = new Fl_Double_Window(1270, 860, "smview 1.0");
    mainWindow->callback((Fl_Callback*)cb_mainWindow, (void*)(this));
    { SongList = new Fl_Tabs(55, 10, 330, 845);
      SongList->callback((Fl_Callback*)cb_SongList, (void*)('S'));
      { TabArtist = new Fl_Group(55, 50, 330, 800, "Artist");
        TabArtist->color(FL_LIGHT1);
        { ArtistBrowser = new Fl_Browser(60, 50, 320, 800);
          ArtistBrowser->type(2);
          ArtistBrowser->selection_color((Fl_Color)175);
          ArtistBrowser->callback((Fl_Callback*)cb_ArtistBrowser);
        } // Fl_Browser* ArtistBrowser
        TabArtist->end();
      } // Fl_Group* TabArtist
      { TabTitle = new Fl_Group(55, 50, 330, 805, "Title");
        TabTitle->color(FL_LIGHT1);
        TabTitle->hide();
        { TitleBrowser = new Fl_Browser(60, 50, 320, 800);
          TitleBrowser->type(2);
          TitleBrowser->selection_color((Fl_Color)175);
          TitleBrowser->callback((Fl_Callback*)cb_TitleBrowser);
        } // Fl_Browser* TitleBrowser
        TabTitle->end();
      } // Fl_Group* TabTitle
      { TabRecent = new Fl_Group(55, 45, 330, 805, "Recent");
        TabRecent->color((Fl_Color)51);
        TabRecent->selection_color(FL_LIGHT1);
        TabRecent->labelcolor(FL_GRAY0);
        TabRecent->hide();
        { RecentBrowser = new Fl_Browser(60, 50, 320, 800);
          RecentBrowser->type(2);
          RecentBrowser->selection_color((Fl_Color)175);
          RecentBrowser->callback((Fl_Callback*)cb_RecentBrowser);
        } // Fl_Browser* RecentBrowser
        TabRecent->end();
      } // Fl_Group* TabRecent
      SongList->end();
    } // Fl_Tabs* SongList
    { HideButton = new Fl_Button(0, 0, 31, 30);
      HideButton->image( image_HIDE() );
      HideButton->callback((Fl_Callback*)cb_HideButton, (void*)('B'));
    } // Fl_Button* HideButton
    { IndexTab = new Fl_Browser(5, 50, 45, 805);
      IndexTab->type(1);
      IndexTab->color((Fl_Color)199);
      IndexTab->selection_color((Fl_Color)55);
      IndexTab->callback((Fl_Callback*)cb_IndexTab, (void*)('I'));
    } // Fl_Browser* IndexTab
    { PDFBox = new PDFWindow(385, 4, 880, 851);
      PDFBox->box(FL_NO_BOX);
      PDFBox->color(FL_BACKGROUND_COLOR);
      PDFBox->selection_color(FL_BACKGROUND_COLOR);
      PDFBox->labeltype(FL_NORMAL_LABEL);
      PDFBox->labelfont(0);
      PDFBox->labelsize(14);
      PDFBox->labelcolor(FL_FOREGROUND_COLOR);
      PDFBox->align(Fl_Align(FL_ALIGN_CENTER));
      PDFBox->when(FL_WHEN_RELEASE);
    } // PDFWindow* PDFBox
    mainWindow->size_range(800, 600);
    mainWindow->end();
  } // Fl_Double_Window* mainWindow
}

void MainUI::show() {
  mainWindow->show(0,NULL);
}

void MainUI::StartsWith(char c) {
  DBSTRUCT *d;
    char ds;
  
    // if Recent is selected, hide the Index menu
    if (SongList->value() == this->TabArtist) {
  		// look for first space+artist
      	for ( int t=1; t<=ArtistBrowser->size(); t++ ) { // index 1 based..!
      		// look for artist heading
      		if (NULL == ArtistBrowser->data(t)) {
      			d = (DBSTRUCT *)(ArtistBrowser->data(t+1));
    			ds = d->line[d->S_artist];
    			if ((c == d->line[d->S_artist]) || ((c == '#') && ((ds >= '0') && (ds <= '9')))) {
      				// select the song
      				ArtistBrowser->value(t+1);
      				this->last_artist = t+1;
      				// if it is not visible, put it at the top
      				if (!ArtistBrowser->visible(t)) ArtistBrowser->topline(t);
      				return;
      			}
      		}
      	}
    }
    if (SongList->value() == this->TabTitle) {
  		// look for first space+artist
      	for ( int t=1; t<=TitleBrowser->size(); t++ ) { // index 1 based..!
      		// look for artist heading
      		if (NULL == TitleBrowser->data(t)) return;
      		d = (DBSTRUCT *)(TitleBrowser->data(t));
    			ds = d->line[d->S_title];
    			if ((c == d->line[d->S_title]) || ((c == '#') && ((ds >= '0') && (ds <= '9')))) {
      				// select the song
      				TitleBrowser->value(t);
      				this->last_title = t;
      				// if it is not visible, put it at the top
      				if (!TitleBrowser->visible(t)) TitleBrowser->topline(t);
      				return;
  			}
  		}
    }
}

void MainUI::init() {
  long i,j;
    	char old_artist[256];
    	char disp_artist[265];
    	char csverr[1024];
    	
    	TitleBrowser->activate();
    	double_clicked = 0;
   	// read the CSV into the database
    	if (read_csv(&db, &dbcount, csvfile, csverr, 1024)) {
    		fl_alert("%s",csverr);
    		exit(-1);	
    	}
    	// load browsers
    	// sort by title, store indexes because array will be blow away by next sort
    	qsort(db, dbcount, sizeof(DBSTRUCT), sort_title);
    	for (i=0; i<dbcount; i++) {
    		if (db[i].title > 0) TitleBrowser->add(&db[i].line[db[i].title], (void *)db[i].index);
    	}
    	// sort recent, store indexes because array will be blow away by next sort
    	qsort(db, dbcount, sizeof(DBSTRUCT), sort_recent);
    	for (i=(dbcount-1); i>=0; i--) {
    		if ((db[i].timestamp > 0) && (db[i].title > 0)) RecentBrowser->add(&db[i].line[db[i].title], (void *)db[i].index);
   	}
    	// sort artist.  this is the final sort.  Use this array order
    	old_artist[0] = 0;
    	strcpy(disp_artist, "@B180@C255 \0");
    	qsort(db, dbcount, sizeof(DBSTRUCT), sort_artist);
    	for (i=0; i<dbcount; i++) {
    		if (db[i].S_artist > 0) {
    			if (strcmp(old_artist, &db[i].line[db[i].S_artist]) != 0) {
    				strcpy(old_artist, &db[i].line[db[i].S_artist]);
    				strcpy(&disp_artist[11],&db[i].line[db[i].artist]);
    				ArtistBrowser->add(disp_artist, NULL);
    			}
    			if (db[i].S_title > 0) {
    				if (db[i].title > 0) ArtistBrowser->add(&db[i].line[db[i].title],(void *)&db[i]);
    			}
    		}
    	}
  	// now go back and reset the data for the other two
  	for (i=1; i<=TitleBrowser->size(); i++) {
  		for (j=0; j<dbcount; j++) {
  			if ((long)TitleBrowser->data(i) == db[j].index) {
  				TitleBrowser->data(i,(void *)&db[j]);
  				break;
  			}
  		}
  	}
  	for (i=1; i<=RecentBrowser->size(); i++) {
  		for (j=0; j<dbcount; j++) {
  			if ((long)RecentBrowser->data(i) == (long)db[j].index) {
  				RecentBrowser->data(i,(void *)&db[j]);
  				break;
  			}
  		}
  	}
  
  	IndexTab->add("@B199@c@b@S24#");
  	for (i='A'; i<='Z'; i++) {
  		sprintf(disp_artist,"@B199@c@b@S24%c",(char)i);
  		IndexTab->add(disp_artist);
  	}
  	mainWindow->resizable(PDFBox);
  	SongList->value(this->TabTitle);
  	sprintf(disp_artist, "smview - %ld Titles Found", dbcount);
    	mainWindow->copy_label(disp_artist);
  	PDFBox->initPDF();
}

void MainUI::ShowPDF(void *v) {
  DBSTRUCT *d = (DBSTRUCT *)v;
  	time_t timer;
      char buffer[26];
      char csverr[64];
      struct tm* tm_info;
  	int i;
  
  //	PDFBox->label(&d->line[d->pdf]);
  	PDFBox->openPDF(&d->line[d->pdf]);
  	// create timestamp
      time(&timer);
      tm_info = localtime(&timer);
      strftime(buffer, 26, "%Y-%m-%d %H:%M:%S", tm_info);
  
  	// add timestamp to entry
  	strcpy(&d->line[d->timestamp],buffer);
  
  	// get entry in recent browser
    	for (i=1; i<=RecentBrowser->size(); i++) {
  		if (RecentBrowser->data(i) == d) {
  			// move from current location to top
  			RecentBrowser->move(1,i);
  			break;
  		}
    	}
  	// if new entry
  	if (i > RecentBrowser->size()) {
  		RecentBrowser->insert(1, &d->line[d->title], (void *)d);
  	}
  	RecentBrowser->select(1,1);
  	// load PDF into box
  	// write CSV back
  	if (write_csv(&db, &dbcount, csvfile, csverr, 64)) {
  		fl_alert("%s", csverr);
  	}
  	// flip mouse over to pdf window
  	XTestFakeMotionEvent(fl_display,-1,mainWindow->x_root() + SongList->x() + SongList->w() + 20,Fl::e_x+mainWindow->y_root(),100);
}

void MainUI::OnClose() {
  PDFBox->closePDF();
  exit(0);
}

void MainUI::HideBrowsers() {
  SongList->hide();
    IndexTab->hide();
    HideButton->hide();
    PDFBox->setFull(1);
}

void MainUI::redraw() {
  if ((PDFBox->IS_FULL == 0) && (!HideButton->visible())) {
    	SongList->show();
    	HideButton->show();
    	if (SongList->value() != RecentBrowser) {
    		IndexTab->show();
    	}
    }
    mainWindow->redraw();
}
